'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _hhmmUtils = require('../utils/hhmm-utils');

var hhmmUtils = _interopRequireWildcard(_hhmmUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Hierarchical HMM decoder <br />
 * Loads a model trained by the XMM library and processes an input stream of float vectors in real-time.
 * If the model was trained for regression, outputs an estimation of the associated process.
 * @class
 */

var HhmmDecoder = function () {

  /**
   * @param {Number} [windowSize=1] - Size of the likelihood smoothing window.
   */
  function HhmmDecoder() {
    var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    (0, _classCallCheck3.default)(this, HhmmDecoder);


    /**
     * Size of the likelihood smoothing window.
     * @type {number}
     * @private
     */
    this._likelihoodWindow = windowSize;

    /**
     * The model, as generated by XMM from a training data set.
     * @type {Object}
     * @private
     */
    this._model = undefined;

    /**
     * The model results, containing intermediate results that will be passed to the callback in filter.
     * @type {Object}
     * @private
     */
    this._modelResults = undefined;
  }

  /**
   * Callback handling estimation results.
   * @callback hhmmResultsCallback
   * @param {string} err - Description of a potential error.
   * @param {hhmmResults} res - Object holding the estimation results.
   */

  /**
   * Results of the filtering process.
   * @typedef hhmmResults
   * @type {Object}
   * @name hhmmResults
   * @property {String} likeliest - The likeliest model's label.
   * @property {Number} likeliestIndex - The likeliest model's index
   * @property {Array.number} likelihoods - The array of all models' smoothed normalized likelihoods.
   * @property {Array.number} timeProgressions - The array of all models' normalized time progressions.
   * @property {Array.Array.number} alphas - The array of all models' states likelihoods array.
   * @property {?Array.number} outputValues - If the model was trained with regression, the estimated float vector output.
   * @property {?Array.number} outputCovariance - If the model was trained with regression, the output covariance matrix.
   */

  /**
   * The decoding function.
   * @param {Array.number} observation - An input float vector to be estimated.
   * @param {hhmmResultsCallback} [resultsCallback=null] - The callback handling the estimation results.
   * @returns {hhmmResults}
   */


  (0, _createClass3.default)(HhmmDecoder, [{
    key: 'filter',
    value: function filter(observation) {
      var resultsCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var err = null;
      var res = null;

      if (!this._model) {
        err = 'no model loaded yet';
      } else {
        try {
          hhmmUtils.hhmmFilter(observation, this._model, this._modelResults);

          // create results object from relevant modelResults values :
          var likeliest = this._modelResults.likeliest > -1 ? this._model.models[this._modelResults.likeliest].label : 'unknown';
          var likelihoods = this._modelResults.smoothed_normalized_likelihoods.slice(0);
          res = {
            likeliest: likeliest,
            likeliestIndex: this._modelResults.likeliest,
            likelihoods: likelihoods,
            timeProgressions: new Array(this._model.models.length),
            alphas: new Array(this._model.models.length)
          };

          for (var i = 0; i < this._model.models.length; i++) {
            res.timeProgressions[i] = this._modelResults.singleClassHmmModelResults[i].progress;
            if (this._model.configuration.default_parameters.hierarchical) {
              res.alphas[i] = this._modelResults.singleClassHmmModelResults[i].alpha_h[0];
            } else {
              res.alphas[i] = this._modelResults.singleClassHmmModelResults[i].alpha[0];
            }
          }

          if (this._model.shared_parameters.bimodal) {
            res['outputValues'] = this._modelResults.output_values.slice(0);
            res['outputCovariance'] = this._modelResults.output_covariance.slice(0);
          }
        } catch (e) {
          err = 'problem occured during filtering : ' + e;
        }
      }

      if (resultsCallback) {
        resultsCallback(err, res);
      }
      return res;
    }

    /**
     * Resets the intermediate results of the estimation (shortcut for reloading the model).
     */

  }, {
    key: 'reset',
    value: function reset() {
      if (this._model) {
        this._setModel(this._model);
      }
    }

    //========================== GETTERS / SETTERS =============================//

    /***
     * Likelihood smoothing window size.
     * @type {Number}
     */
    // get likelihoodWindow() {
    //   return this._likelihoodWindow;
    // }

    // set likelihoodWindow(newWindowSize) {
    //   this._likelihoodWindow = newWindowSize;
    //   this._updateLikelihoodWindow();
    // }

    /**
     * Get the likelihood smoothing window size.
     * @returns {Number}
     */

  }, {
    key: 'getLikelihoodWindow',
    value: function getLikelihoodWindow() {
      return this._likelihoodWindow;
    }

    /**
     * Set the likelihood smoothing window size.
     * @param {Number} newWindowSize - the new window size.
     */

  }, {
    key: 'setLikelihoodWindow',
    value: function setLikelihoodWindow(newWindowSize) {
      this._likelihoodWindow = newWindowSize;
      this._updateLikelihoodWindow();
    }

    /** @private */

  }, {
    key: '_updateLikelihoodWindow',
    value: function _updateLikelihoodWindow() {
      if (this._model === undefined) return;

      var res = this._modelResults.singleClassHmmModelResults;

      for (var i = 0; i < this._model.models.length; i++) {
        res[i].likelihood_buffer = new Array(this._likelihoodWindow);

        for (var j = 0; j < this._likelihoodWindow; j++) {
          res[i].likelihood_buffer[j] = 1 / this._likelihoodWindow;
        }
      }
    }

    /**
     * A valid XMM Hierarchical HMM model
     * @typedef xmmHhmmModel
     * @type {Object}
     * @name xmmHhmmModel
     * @property {String} TODO - LIST REAL HHMM MODEL PROPERTIES HERE
     */

    /***
     * The model generated by XMM.
     * It is mandatory for the class to have a model in order to do its job.
     * @type {xmmHhmmModel}
     */
    // get model() {
    //   return this.getModel();
    // }

    // set model(model) {
    //   this.setModel(model);
    // }

    /**
     * Get the actual XMM Hierarchical HMM model.
     * @returns {xmmHhmmModel}
     */

  }, {
    key: 'getModel',
    value: function getModel() {
      if (this._model) {
        return JSON.parse((0, _stringify2.default)(this._model));
      }
      return undefined;
    }

    /**
     * Set the actual XMM Hierarchical HMM model.
     * @param {xmmHhmmModel} model
     */

  }, {
    key: 'setModel',
    value: function setModel(model) {
      this._setModel(model);
    }

    /** @private */

  }, {
    key: '_setModel',
    value: function _setModel(model) {

      this._model = undefined;
      this._modelResults = undefined;

      if (!model) return;

      // test if model is valid here (TODO : write a better test)
      if (model.models !== undefined) {
        this._model = model;
        var m = this._model;
        var nmodels = m.models.length;

        this._modelResults = {
          instant_likelihoods: new Array(nmodels),
          smoothed_log_likelihoods: new Array(nmodels),
          smoothed_likelihoods: new Array(nmodels),
          instant_normalized_likelihoods: new Array(nmodels),
          smoothed_normalized_likelihoods: new Array(nmodels),
          likeliest: -1,
          frontier_v1: new Array(nmodels),
          frontier_v2: new Array(nmodels),
          forward_initialized: false,
          singleClassHmmModelResults: []
        };

        var params = m.shared_parameters;
        var dimOut = params.dimension - params.dimension_input;
        this._modelResults.output_values = new Array(dimOut);
        for (var i = 0; i < dimOut; i++) {
          this._modelResults.output_values[i] = 0.0;
        }

        var outCovarSize = void 0;
        if (m.configuration.default_parameters.covariance_mode == 0) {
          //---- full
          outCovarSize = dimOut * dimOut;
        } else {
          //------------------------------------------------------ diagonal
          outCovarSize = dimOut;
        }

        this._modelResults.output_covariance = new Array(outCovarSize);

        for (var _i = 0; _i < dimOut; _i++) {
          this._modelResults.output_covariance[_i] = 0.0;
        }

        for (var _i2 = 0; _i2 < nmodels; _i2++) {
          this._modelResults.instant_likelihoods[_i2] = 0;
          this._modelResults.smoothed_log_likelihoods[_i2] = 0;
          this._modelResults.smoothed_likelihoods[_i2] = 0;
          this._modelResults.instant_normalized_likelihoods[_i2] = 0;
          this._modelResults.smoothed_normalized_likelihoods[_i2] = 0;

          var nstates = m.models[_i2].parameters.states;

          var alpha_h = new Array(3);
          for (var j = 0; j < 3; j++) {
            alpha_h[j] = new Array(nstates);
            for (var k = 0; k < nstates; k++) {
              alpha_h[j][k] = 0;
            }
          }

          var alpha = new Array(nstates);
          for (var _j = 0; _j < nstates; _j++) {
            alpha[_j] = 0;
          }

          var likelihood_buffer = new Array(this._likelihoodWindow);
          for (var _j2 = 0; _j2 < this._likelihoodWindow; _j2++) {
            likelihood_buffer[_j2] = 0.0;
          }

          var hmmRes = {
            hierarchical: m.configuration.default_parameters.hierarchical,
            instant_likelihood: 0,
            log_likelihood: 0,
            // for circular buffer implementation
            // (see hmmUpdateResults) :
            likelihood_buffer: likelihood_buffer,
            likelihood_buffer_index: 0,
            progress: 0,

            exit_likelihood: 0,
            exit_ratio: 0,

            likeliest_state: -1,

            // for non-hierarchical :
            previous_alpha: alpha.slice(0),
            alpha: alpha,
            // for hierarchical :       
            alpha_h: alpha_h,
            prior: new Array(nstates),
            transition: new Array(nstates),

            // used in hmmUpdateAlphaWindow
            window_minindex: 0,
            window_maxindex: 0,
            window_normalization_constant: 0,

            // for non-hierarchical mode
            forward_initialized: false,

            singleClassGmmModelResults: [] // aka states
          };

          hmmRes.output_values = this._modelResults.output_values.slice(0);
          hmmRes.output_covariance = this._modelResults.output_covariance.slice(0);

          // add HMM states (GMMs)
          for (var _j3 = 0; _j3 < nstates; _j3++) {
            var gmmRes = {
              instant_likelihood: 0,
              log_likelihood: 0
            };
            gmmRes.beta = new Array(this._model.models[_i2].parameters.gaussians);
            for (var _k = 0; _k < gmmRes.beta.length; _k++) {
              gmmRes.beta[_k] = 1 / gmmRes.beta.length;
            }
            gmmRes.output_values = hmmRes.output_values.slice(0);
            gmmRes.output_covariance = hmmRes.output_covariance.slice(0);

            hmmRes.singleClassGmmModelResults.push(gmmRes);
          }

          this._modelResults.singleClassHmmModelResults.push(hmmRes);
        }
      }
    }

    /***
     * Currently estimated likeliest label.
     * @readonly
     * @type {String}
     */
    // get likeliestLabel() {
    //   return this.getLikeliestLabel();
    // }

    /**
     * Get the currently estimated likeliest label.
     * @returns {String}
     */

  }, {
    key: 'getLikeliestLabel',
    value: function getLikeliestLabel() {
      if (this._modelResults) {
        if (this._modelResults.likeliest > -1) {
          return this._model.models[this._modelResults.likeliest].label;
        }
      }
      return 'unknown';
    }

    /***
     * Number of classes contained in the model.
     * @readonly
     * @type {Number}
     */
    // get nbClasses() {
    //   return this.getNumberOfClasses();
    // }

    /**
     * Get the total number of classes the model was trained with.
     * @returns {Number}
     */

  }, {
    key: 'getNumberOfClasses',
    value: function getNumberOfClasses() {
      if (this._model) {
        return this._model.models.length;
      }
      return 0;
    }

    /***
     * Size of the regression vector if model is bimodal.
     * @readonly
     * @type {Number}
     */
    // get regressionSize() {
    //   return this.getRegressionVectorSize();
    // }

    /**
     * Get the output dimension of the model (size of a regression vector).
     * @returns {Number}
     */

  }, {
    key: 'getRegressionVectorSize',
    value: function getRegressionVectorSize() {
      if (this._model) {
        var params = this._model.shared_parameters;
        return params['bimodal'] ? params['dimension'] - params['dimension_input'] : 0;
      }
      return 0;
    }
  }]);
  return HhmmDecoder;
}();

;

exports.default = HhmmDecoder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImhobW0tZGVjb2Rlci5qcyJdLCJuYW1lcyI6WyJoaG1tVXRpbHMiLCJIaG1tRGVjb2RlciIsIndpbmRvd1NpemUiLCJfbGlrZWxpaG9vZFdpbmRvdyIsIl9tb2RlbCIsInVuZGVmaW5lZCIsIl9tb2RlbFJlc3VsdHMiLCJvYnNlcnZhdGlvbiIsInJlc3VsdHNDYWxsYmFjayIsImVyciIsInJlcyIsImhobW1GaWx0ZXIiLCJsaWtlbGllc3QiLCJtb2RlbHMiLCJsYWJlbCIsImxpa2VsaWhvb2RzIiwic21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kcyIsInNsaWNlIiwibGlrZWxpZXN0SW5kZXgiLCJ0aW1lUHJvZ3Jlc3Npb25zIiwiQXJyYXkiLCJsZW5ndGgiLCJhbHBoYXMiLCJpIiwic2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHMiLCJwcm9ncmVzcyIsImNvbmZpZ3VyYXRpb24iLCJkZWZhdWx0X3BhcmFtZXRlcnMiLCJoaWVyYXJjaGljYWwiLCJhbHBoYV9oIiwiYWxwaGEiLCJzaGFyZWRfcGFyYW1ldGVycyIsImJpbW9kYWwiLCJvdXRwdXRfdmFsdWVzIiwib3V0cHV0X2NvdmFyaWFuY2UiLCJlIiwiX3NldE1vZGVsIiwibmV3V2luZG93U2l6ZSIsIl91cGRhdGVMaWtlbGlob29kV2luZG93IiwibGlrZWxpaG9vZF9idWZmZXIiLCJqIiwiSlNPTiIsInBhcnNlIiwibW9kZWwiLCJtIiwibm1vZGVscyIsImluc3RhbnRfbGlrZWxpaG9vZHMiLCJzbW9vdGhlZF9sb2dfbGlrZWxpaG9vZHMiLCJzbW9vdGhlZF9saWtlbGlob29kcyIsImluc3RhbnRfbm9ybWFsaXplZF9saWtlbGlob29kcyIsImZyb250aWVyX3YxIiwiZnJvbnRpZXJfdjIiLCJmb3J3YXJkX2luaXRpYWxpemVkIiwicGFyYW1zIiwiZGltT3V0IiwiZGltZW5zaW9uIiwiZGltZW5zaW9uX2lucHV0Iiwib3V0Q292YXJTaXplIiwiY292YXJpYW5jZV9tb2RlIiwibnN0YXRlcyIsInBhcmFtZXRlcnMiLCJzdGF0ZXMiLCJrIiwiaG1tUmVzIiwiaW5zdGFudF9saWtlbGlob29kIiwibG9nX2xpa2VsaWhvb2QiLCJsaWtlbGlob29kX2J1ZmZlcl9pbmRleCIsImV4aXRfbGlrZWxpaG9vZCIsImV4aXRfcmF0aW8iLCJsaWtlbGllc3Rfc3RhdGUiLCJwcmV2aW91c19hbHBoYSIsInByaW9yIiwidHJhbnNpdGlvbiIsIndpbmRvd19taW5pbmRleCIsIndpbmRvd19tYXhpbmRleCIsIndpbmRvd19ub3JtYWxpemF0aW9uX2NvbnN0YW50Iiwic2luZ2xlQ2xhc3NHbW1Nb2RlbFJlc3VsdHMiLCJnbW1SZXMiLCJiZXRhIiwiZ2F1c3NpYW5zIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0lBQVlBLFM7Ozs7OztBQUVaOzs7Ozs7O0lBT01DLFc7O0FBRUo7OztBQUdBLHlCQUE0QjtBQUFBLFFBQWhCQyxVQUFnQix1RUFBSCxDQUFHO0FBQUE7OztBQUUxQjs7Ozs7QUFLQSxTQUFLQyxpQkFBTCxHQUF5QkQsVUFBekI7O0FBRUE7Ozs7O0FBS0EsU0FBS0UsTUFBTCxHQUFjQyxTQUFkOztBQUVBOzs7OztBQUtBLFNBQUtDLGFBQUwsR0FBcUJELFNBQXJCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTs7Ozs7Ozs7Ozs7Ozs7QUFjQTs7Ozs7Ozs7OzsyQkFNT0UsVyxFQUFxQztBQUFBLFVBQXhCQyxlQUF3Qix1RUFBTixJQUFNOztBQUMxQyxVQUFJQyxNQUFNLElBQVY7QUFDQSxVQUFJQyxNQUFNLElBQVY7O0FBRUEsVUFBRyxDQUFDLEtBQUtOLE1BQVQsRUFBaUI7QUFDZkssY0FBTSxxQkFBTjtBQUNELE9BRkQsTUFFTztBQUNMLFlBQUk7QUFDRlQsb0JBQVVXLFVBQVYsQ0FBcUJKLFdBQXJCLEVBQWtDLEtBQUtILE1BQXZDLEVBQStDLEtBQUtFLGFBQXBEOztBQUVBO0FBQ0EsY0FBTU0sWUFBYSxLQUFLTixhQUFMLENBQW1CTSxTQUFuQixHQUErQixDQUFDLENBQWpDLEdB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OENBSTBCO0FBQ3hCLFVBQUksS0FBS2pCLE1BQVQsRUFBaUI7QUFDZixZQUFNaUQsU0FBUyxLQUFLakQsTUFBTCxDQUFZMkIsaUJBQTNCO0FBQ0EsZUFBT3NCLE9BQU8sU0FBUCxJQUNBQSxPQUFPLFdBQVAsSUFBc0JBLE9BQU8saUJBQVAsQ0FEdEIsR0FFQSxDQUZQO0FBR0Q7QUFDRCxhQUFPLENBQVA7QUFDRDs7Ozs7QUFDRjs7a0JBRWNwRCxXIiwiZmlsZSI6ImhobW0tZGVjb2Rlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGhobW1VdGlscyBmcm9tICcuLi91dGlscy9oaG1tLXV0aWxzJztcblxuLyoqXG4gKiBIaWVyYXJjaGljYWwgSE1NIGRlY29kZXIgPGJyIC8+XG4gKiBMb2FkcyBhIG1vZGVsIHRyYWluZWQgYnkgdGhlIFhNTSBsaWJyYXJ5IGFuZCBwcm9jZXNzZXMgYW4gaW5wdXQgc3RyZWFtIG9mIGZsb2F0IHZlY3RvcnMgaW4gcmVhbC10aW1lLlxuICogSWYgdGhlIG1vZGVsIHdhcyB0cmFpbmVkIGZvciByZWdyZXNzaW9uLCBvdXRwdXRzIGFuIGVzdGltYXRpb24gb2YgdGhlIGFzc29jaWF0ZWQgcHJvY2Vzcy5cbiAqIEBjbGFzc1xuICovXG5cbmNsYXNzIEhobW1EZWNvZGVyIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aW5kb3dTaXplPTFdIC0gU2l6ZSBvZiB0aGUgbGlrZWxpaG9vZCBzbW9vdGhpbmcgd2luZG93LlxuICAgKi9cbiAgY29uc3RydWN0b3Iod2luZG93U2l6ZSA9IDEpIHtcblxuICAgIC8qKlxuICAgICAqIFNpemUgb2YgdGhlIGxpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvdy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbGlrZWxpaG9vZFdpbmRvdyA9IHdpbmRvd1NpemU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9kZWwsIGFzIGdlbmVyYXRlZCBieSBYTU0gZnJvbSBhIHRyYWluaW5nIGRhdGEgc2V0LlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9tb2RlbCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCByZXN1bHRzLCBjb250YWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGluIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbW9kZWxSZXN1bHRzID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGhhbmRsaW5nIGVzdGltYXRpb24gcmVzdWx0cy5cbiAgICogQGNhbGxiYWNrIGhobW1SZXN1bHRzQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVyciAtIERlc2NyaXB0aW9uIG9mIGEgcG90ZW50aWFsIGVycm9yLlxuICAgKiBAcGFyYW0ge2hobW1SZXN1bHRzfSByZXMgLSBPYmplY3QgaG9sZGluZyB0aGUgZXN0aW1hdGlvbiByZXN1bHRzLlxuICAgKi9cblxuICAvKipcbiAgICogUmVzdWx0cyBvZiB0aGUgZmlsdGVyaW5nIHByb2Nlc3MuXG4gICAqIEB0eXBlZGVmIGhobW1SZXN1bHRzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBuYW1lIGhobW1SZXN1bHRzXG4gICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBsaWtlbGllc3QgLSBUaGUgbGlrZWxpZXN0IG1vZGVsJ3MgbGFiZWwuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBsaWtlbGllc3RJbmRleCAtIFRoZSBsaWtlbGllc3QgbW9kZWwncyBpbmRleFxuICAgKiBAcHJvcGVydHkge0FycmF5Lm51bWJlcn0gbGlrZWxpaG9vZHMgLSBUaGUgYXJyYXkgb2YgYWxsIG1vZGVscycgc21vb3RoZWQgbm9ybWFsaXplZCBsaWtlbGlob29kcy5cbiAgICogQHByb3BlcnR5IHtBcnJheS5udW1iZXJ9IHRpbWVQcm9ncmVzc2lvbnMgLSBUaGUgYXJyYXkgb2YgYWxsIG1vZGVscycgbm9ybWFsaXplZCB0aW1lIHByb2dyZXNzaW9ucy5cbiAgICogQHByb3BlcnR5IHtBcnJheS5BcnJheS5udW1iZXJ9IGFscGhhcyAtIFRoZSBhcnJheSBvZiBhbGwgbW9kZWxzJyBzdGF0ZXMgbGlrZWxpaG9vZHMgYXJyYXkuXG4gICAqIEBwcm9wZXJ0eSB7P0FycmF5Lm51bWJlcn0gb3V0cHV0VmFsdWVzIC0gSWYgdGhlIG1vZGVsIHdhcyB0cmFpbmVkIHdpdGggcmVncmVzc2lvbiwgdGhlIGVzdGltYXRlZCBmbG9hdCB2ZWN0b3Igb3V0cHV0LlxuICAgKiBAcHJvcGVydHkgez9BcnJheS5udW1iZXJ9IG91dHB1dENvdmFyaWFuY2UgLSBJZiB0aGUgbW9kZWwgd2FzIHRyYWluZWQgd2l0aCByZWdyZXNzaW9uLCB0aGUgb3V0cHV0IGNvdmFyaWFuY2UgbWF0cml4LlxuICAgKi9cblxuICAvKipcbiAgICogVGhlIGRlY29kaW5nIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge0FycmF5Lm51bWJlcn0gb2JzZXJ2YXRpb24gLSBBbiBpbnB1dCBmbG9hdCB2ZWN0b3IgdG8gYmUgZXN0aW1hdGVkLlxuICAgKiBAcGFyYW0ge2hobW1SZXN1bHRzQ2FsbGJhY2t9IFtyZXN1bHRzQ2FsbGJhY2s9bnVsbF0gLSBUaGUgY2FsbGJhY2sgaGFuZGxpbmcgdGhlIGVzdGltYXRpb24gcmVzdWx0cy5cbiAgICogQHJldHVybnMge2hobW1SZXN1bHRzfVxuICAgKi9cbiAgZmlsdGVyKG9ic2VydmF0aW9uLCByZXN1bHRzQ2FsbGJhY2sgPSBudWxsKSB7XG4gICAgbGV0IGVyciA9IG51bGw7XG4gICAgbGV0IHJlcyA9IG51bGw7XG5cbiAgICBpZighdGhpcy5fbW9kZWwpIHtcbiAgICAgIGVyciA9ICdubyBtb2RlbCBsb2FkZWQgeWV0JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaGhtbVV0aWxzLmhobW1GaWx0ZXIob2JzZXJ2YXRpb24sIHRoaXMuX21vZGVsLCB0aGlzLl9tb2RlbFJlc3VsdHMpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSByZXN1bHRzIG9iamVjdCBmcm9tIHJlbGV2YW50IG1vZGVsUmVzdWx0cyB2YWx1ZXMgOlxuICAgICAgICBjb25zdCBsaWtlbGllc3QgPSAodGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9tb2RlbC5tb2RlbHNbdGhpcy5fbW9kZWxSZXN1bHRzLmxpa2VsaWVzdF0ubGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ3Vua25vd24nO1xuICAgICAgICBjb25zdCBsaWtlbGlob29kcyA9IHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzLnNsaWNlKDApO1xuICAgICAgICByZXMgPSB7XG4gICAgICAgICAgbGlrZWxpZXN0OiBsaWtlbGllc3QsXG4gICAgICAgICAgbGlrZWxpZXN0SW5kZXg6IHRoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3QsXG4gICAgICAgICAgbGlrZWxpaG9vZHM6IGxpa2VsaWhvb2RzLFxuICAgICAgICAgIHRpbWVQcm9ncmVzc2lvbnM6IG5ldyBBcnJheSh0aGlzLl9tb2RlbC5tb2RlbHMubGVuZ3RoKSxcbiAgICAgICAgICBhbHBoYXM6IG5ldyBBcnJheSh0aGlzLl9tb2RlbC5tb2RlbHMubGVuZ3RoKVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbW9kZWwubW9kZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVzLnRpbWVQcm9ncmVzc2lvbnNbaV0gPSB0aGlzLl9tb2RlbFJlc3VsdHMuc2luZ2xlQ2xhc3NIbW1Nb2RlbFJlc3VsdHNbaV0ucHJvZ3Jlc3M7XG4gICAgICAgICAgaWYgKHRoaXMuX21vZGVsLmNvbmZpZ3VyYXRpb24uZGVmYXVsdF9wYXJhbWV0ZXJzLmhpZXJhcmNoaWNhbCkge1xuICAgICAgICAgICAgcmVzLmFscGhhc1tpXVxuICAgICAgICAgICAgICA9IHRoaXMuX21vZGVsUmVzdWx0cy5zaW5nbGVDbGFzc0htbU1vZGVsUmVzdWx0c1tpXS5hbHBoYV9oWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMuYWxwaGFzW2ldXG4gICAgICAgICAgICAgID0gdGhpcy5fbW9kZWxSZXN1bHRzLnNpbmdsZUNsYXNzSG1tTW9kZWxSZXN1bHRzW2ldLmFscGhhWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tb2RlbC5zaGFyZWRfcGFyYW1ldGVycy5iaW1vZGFsKSB7XG4gICAgICAgICAgcmVzWydvdXRwdXRWYWx1ZXMnXSA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAgIHJlc1snb3V0cHV0Q292YXJpYW5jZSddXG4gICAgICAgICAgICAgID0gdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF9jb3ZhcmlhbmNlLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9ICdwcm9ibGVtIG9jY3VyZWQgZHVyaW5nIGZpbHRlcmluZyA6ICcgKyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZXN1bHRzQ2FsbGJhY2spIHtcbiAgICAgIHJlc3VsdHNDYWxsYmFjayhlcnIsIHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoZSBpbnRlcm1lZGlhdGUgcmVzdWx0cyBvZiB0aGUgZXN0aW1hdGlvbiAoc2hvcnRjdXQgZm9yIHJlbG9hZGluZyB0aGUgbW9kZWwpLlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuX21vZGVsKSB7XG4gICAgICB0aGlzLl9zZXRNb2RlbCh0aGlzLl9tb2RlbCk7XG4gICAgfVxuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PSBHRVRURVJTIC8gU0VUVEVSUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PS8vXG5cbiAgLyoqKlxuICAgKiBMaWtlbGlob29kIHNtb290aGluZyB3aW5kb3cgc2l6ZS5cbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIC8vIGdldCBsaWtlbGlob29kV2luZG93KCkge1xuICAvLyAgIHJldHVybiB0aGlzLl9saWtlbGlob29kV2luZG93O1xuICAvLyB9XG5cbiAgLy8gc2V0IGxpa2VsaWhvb2RXaW5kb3cobmV3V2luZG93U2l6ZSkge1xuICAvLyAgIHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cgPSBuZXdXaW5kb3dTaXplO1xuICAvLyAgIHRoaXMuX3VwZGF0ZUxpa2VsaWhvb2RXaW5kb3coKTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvdyBzaXplLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0TGlrZWxpaG9vZFdpbmRvdygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGlrZWxpaG9vZFdpbmRvdztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGxpa2VsaWhvb2Qgc21vb3RoaW5nIHdpbmRvdyBzaXplLlxuICAgKiBAcGFyYW0ge051bWJlcn0gbmV3V2luZG93U2l6ZSAtIHRoZSBuZXcgd2luZG93IHNpemUuXG4gICAqL1xuICBzZXRMaWtlbGlob29kV2luZG93KG5ld1dpbmRvd1NpemUpIHtcbiAgICB0aGlzLl9saWtlbGlob29kV2luZG93ID0gbmV3V2luZG93U2l6ZTtcbiAgICB0aGlzLl91cGRhdGVMaWtlbGlob29kV2luZG93KCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgX3VwZGF0ZUxpa2VsaWhvb2RXaW5kb3coKSB7XG4gICAgaWYgKHRoaXMuX21vZGVsID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIGNvbnN0IHJlcyA9IHRoaXMuX21vZGVsUmVzdWx0cy5zaW5nbGVDbGFzc0htbU1vZGVsUmVzdWx0cztcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21vZGVsLm1vZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzW2ldLmxpa2VsaWhvb2RfYnVmZmVyID0gbmV3IEFycmF5KHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cpO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7IGorKykge1xuICAgICAgICByZXNbaV0ubGlrZWxpaG9vZF9idWZmZXJbal0gPSAxIC8gdGhpcy5fbGlrZWxpaG9vZFdpbmRvdztcbiAgICAgIH1cbiAgICB9ICAgIFxuICB9XG5cbiAgLyoqXG4gICAqIEEgdmFsaWQgWE1NIEhpZXJhcmNoaWNhbCBITU0gbW9kZWxcbiAgICogQHR5cGVkZWYgeG1tSGhtbU1vZGVsXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBuYW1lIHhtbUhobW1Nb2RlbFxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gVE9ETyAtIExJU1QgUkVBTCBISE1NIE1PREVMIFBST1BFUlRJRVMgSEVSRVxuICAgKi9cblxuICAvKioqXG4gICAqIFRoZSBtb2RlbCBnZW5lcmF0ZWQgYnkgWE1NLlxuICAgKiBJdCBpcyBtYW5kYXRvcnkgZm9yIHRoZSBjbGFzcyB0byBoYXZlIGEgbW9kZWwgaW4gb3JkZXIgdG8gZG8gaXRzIGpvYi5cbiAgICogQHR5cGUge3htbUhobW1Nb2RlbH1cbiAgICovXG4gIC8vIGdldCBtb2RlbCgpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5nZXRNb2RlbCgpO1xuICAvLyB9XG5cbiAgLy8gc2V0IG1vZGVsKG1vZGVsKSB7XG4gIC8vICAgdGhpcy5zZXRNb2RlbChtb2RlbCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBhY3R1YWwgWE1NIEhpZXJhcmNoaWNhbCBITU0gbW9kZWwuXG4gICAqIEByZXR1cm5zIHt4bW1IaG1tTW9kZWx9XG4gICAqL1xuICBnZXRNb2RlbCgpIHtcbiAgICBpZiAodGhpcy5fbW9kZWwpIHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX21vZGVsKSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7ICAgIFxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYWN0dWFsIFhNTSBIaWVyYXJjaGljYWwgSE1NIG1vZGVsLlxuICAgKiBAcGFyYW0ge3htbUhobW1Nb2RlbH0gbW9kZWxcbiAgICovXG4gIHNldE1vZGVsKG1vZGVsKSB7XG4gICAgdGhpcy5fc2V0TW9kZWwobW9kZWwpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIF9zZXRNb2RlbChtb2RlbCkgeyAgICAgIFxuXG4gICAgdGhpcy5fbW9kZWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbW9kZWxSZXN1bHRzID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFtb2RlbCkgcmV0dXJuO1xuXG4gICAgLy8gdGVzdCBpZiBtb2RlbCBpcyB2YWxpZCBoZXJlIChUT0RPIDogd3JpdGUgYSBiZXR0ZXIgdGVzdClcbiAgICBpZiAobW9kZWwubW9kZWxzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gICAgICBjb25zdCBtID0gdGhpcy5fbW9kZWw7XG4gICAgICBjb25zdCBubW9kZWxzID0gbS5tb2RlbHMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9tb2RlbFJlc3VsdHMgPSB7XG4gICAgICAgIGluc3RhbnRfbGlrZWxpaG9vZHM6IG5ldyBBcnJheShubW9kZWxzKSxcbiAgICAgICAgc21vb3RoZWRfbG9nX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIHNtb290aGVkX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGluc3RhbnRfbm9ybWFsaXplZF9saWtlbGlob29kczogbmV3IEFycmF5KG5tb2RlbHMpLFxuICAgICAgICBzbW9vdGhlZF9ub3JtYWxpemVkX2xpa2VsaWhvb2RzOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGxpa2VsaWVzdDogLTEsXG4gICAgICAgIGZyb250aWVyX3YxOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGZyb250aWVyX3YyOiBuZXcgQXJyYXkobm1vZGVscyksXG4gICAgICAgIGZvcndhcmRfaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgICBzaW5nbGVDbGFzc0htbU1vZGVsUmVzdWx0czogW11cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHBhcmFtcyA9IG0uc2hhcmVkX3BhcmFtZXRlcnM7XG4gICAgICBjb25zdCBkaW1PdXQgPSBwYXJhbXMuZGltZW5zaW9uIC0gcGFyYW1zLmRpbWVuc2lvbl9pbnB1dDtcbiAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzID0gbmV3IEFycmF5KGRpbU91dCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbU91dDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfdmFsdWVzW2ldID0gMC4wO1xuICAgICAgfVxuXG4gICAgICBsZXQgb3V0Q292YXJTaXplO1xuICAgICAgaWYgKG0uY29uZmlndXJhdGlvbi5kZWZhdWx0X3BhcmFtZXRlcnMuY292YXJpYW5jZV9tb2RlID09IDApIHsgLy8tLS0tIGZ1bGxcbiAgICAgICAgb3V0Q292YXJTaXplID0gZGltT3V0ICogZGltT3V0O1xuICAgICAgfSBlbHNlIHsgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZGlhZ29uYWxcbiAgICAgICAgb3V0Q292YXJTaXplID0gZGltT3V0O1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2UgPSBuZXcgQXJyYXkob3V0Q292YXJTaXplKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1PdXQ7IGkrKykge1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMub3V0cHV0X2NvdmFyaWFuY2VbaV0gPSAwLjA7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm1vZGVsczsgaSsrKSB7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5pbnN0YW50X2xpa2VsaWhvb2RzW2ldID0gMDtcbiAgICAgICAgdGhpcy5fbW9kZWxSZXN1bHRzLnNtb290aGVkX2xvZ19saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5zbW9vdGhlZF9saWtlbGlob29kc1tpXSA9IDA7XG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5pbnN0YW50X25vcm1hbGl6ZWRfbGlrZWxpaG9vZHNbaV0gPSAwO1xuICAgICAgICB0aGlzLl9tb2RlbFJlc3VsdHMuc21vb3RoZWRfbm9ybWFsaXplZF9saWtlbGlob29kc1tpXSA9IDA7XG5cbiAgICAgICAgY29uc3QgbnN0YXRlcyA9IG0ubW9kZWxzW2ldLnBhcmFtZXRlcnMuc3RhdGVzO1xuXG4gICAgICAgIGNvbnN0IGFscGhhX2ggPSBuZXcgQXJyYXkoMyk7XG4gICAgICAgIGZvciAobGV0IGo9MDsgajwzOyBqKyspIHtcbiAgICAgICAgICBhbHBoYV9oW2pdID0gbmV3IEFycmF5KG5zdGF0ZXMpO1xuICAgICAgICAgIGZvciAobGV0IGs9MDsgazxuc3RhdGVzOyBrKyspIHtcbiAgICAgICAgICAgIGFscGhhX2hbal1ba10gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgYWxwaGEgPSBuZXcgQXJyYXkobnN0YXRlcyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnN0YXRlczsgaisrKSB7XG4gICAgICAgICAgYWxwaGFbal0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxpa2VsaWhvb2RfYnVmZmVyID0gbmV3IEFycmF5KHRoaXMuX2xpa2VsaWhvb2RXaW5kb3cpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX2xpa2VsaWhvb2RXaW5kb3c7IGorKykge1xuICAgICAgICAgIGxpa2VsaWhvb2RfYnVmZmVyW2pdID0gMC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaG1tUmVzID0ge1xuICAgICAgICAgIGhpZXJhcmNoaWNhbDogbS5jb25maWd1cmF0aW9uLmRlZmF1bHRfcGFyYW1ldGVycy5oaWVyYXJjaGljYWwsXG4gICAgICAgICAgaW5zdGFudF9saWtlbGlob29kOiAwLFxuICAgICAgICAgIGxvZ19saWtlbGlob29kOiAwLFxuICAgICAgICAgIC8vIGZvciBjaXJjdWxhciBidWZmZXIgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICAvLyAoc2VlIGhtbVVwZGF0ZVJlc3VsdHMpIDpcbiAgICAgICAgICBsaWtlbGlob29kX2J1ZmZlcjogbGlrZWxpaG9vZF9idWZmZXIsXG4gICAgICAgICAgbGlrZWxpaG9vZF9idWZmZXJfaW5kZXg6IDAsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsXG5cbiAgICAgICAgICBleGl0X2xpa2VsaWhvb2Q6IDAsXG4gICAgICAgICAgZXhpdF9yYXRpbzogMCxcblxuICAgICAgICAgIGxpa2VsaWVzdF9zdGF0ZTogLTEsXG5cbiAgICAgICAgICAvLyBmb3Igbm9uLWhpZXJhcmNoaWNhbCA6XG4gICAgICAgICAgcHJldmlvdXNfYWxwaGE6IGFscGhhLnNsaWNlKDApLFxuICAgICAgICAgIGFscGhhOiBhbHBoYSxcbiAgICAgICAgICAvLyBmb3IgaGllcmFyY2hpY2FsIDogICAgICAgXG4gICAgICAgICAgYWxwaGFfaDogYWxwaGFfaCxcbiAgICAgICAgICBwcmlvcjogbmV3IEFycmF5KG5zdGF0ZXMpLFxuICAgICAgICAgIHRyYW5zaXRpb246IG5ldyBBcnJheShuc3RhdGVzKSxcblxuICAgICAgICAgIC8vIHVzZWQgaW4gaG1tVXBkYXRlQWxwaGFXaW5kb3dcbiAgICAgICAgICB3aW5kb3dfbWluaW5kZXg6IDAsXG4gICAgICAgICAgd2luZG93X21heGluZGV4OiAwLFxuICAgICAgICAgIHdpbmRvd19ub3JtYWxpemF0aW9uX2NvbnN0YW50OiAwLFxuXG4gICAgICAgICAgLy8gZm9yIG5vbi1oaWVyYXJjaGljYWwgbW9kZVxuICAgICAgICAgIGZvcndhcmRfaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICAgICAgICAgIFxuICAgICAgICAgIHNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzOiBbXSAgLy8gYWthIHN0YXRlc1xuICAgICAgICB9O1xuXG4gICAgICAgIGhtbVJlcy5vdXRwdXRfdmFsdWVzID0gdGhpcy5fbW9kZWxSZXN1bHRzLm91dHB1dF92YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgIGhtbVJlcy5vdXRwdXRfY292YXJpYW5jZSA9IHRoaXMuX21vZGVsUmVzdWx0cy5vdXRwdXRfY292YXJpYW5jZS5zbGljZSgwKTtcblxuICAgICAgICAvLyBhZGQgSE1NIHN0YXRlcyAoR01NcylcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuc3RhdGVzOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBnbW1SZXMgPSB7XG4gICAgICAgICAgICBpbnN0YW50X2xpa2VsaWhvb2Q6IDAsXG4gICAgICAgICAgICBsb2dfbGlrZWxpaG9vZDogMFxuICAgICAgICAgIH07XG4gICAgICAgICAgZ21tUmVzLmJldGEgPSBuZXcgQXJyYXkodGhpcy5fbW9kZWwubW9kZWxzW2ldLnBhcmFtZXRlcnMuZ2F1c3NpYW5zKTtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGdtbVJlcy5iZXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBnbW1SZXMuYmV0YVtrXSA9IDEgLyBnbW1SZXMuYmV0YS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdtbVJlcy5vdXRwdXRfdmFsdWVzID0gaG1tUmVzLm91dHB1dF92YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgZ21tUmVzLm91dHB1dF9jb3ZhcmlhbmNlID0gaG1tUmVzLm91dHB1dF9jb3ZhcmlhbmNlLnNsaWNlKDApO1xuXG4gICAgICAgICAgaG1tUmVzLnNpbmdsZUNsYXNzR21tTW9kZWxSZXN1bHRzLnB1c2goZ21tUmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vZGVsUmVzdWx0cy5zaW5nbGVDbGFzc0htbU1vZGVsUmVzdWx0cy5wdXNoKGhtbVJlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqKlxuICAgKiBDdXJyZW50bHkgZXN0aW1hdGVkIGxpa2VsaWVzdCBsYWJlbC5cbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICAvLyBnZXQgbGlrZWxpZXN0TGFiZWwoKSB7XG4gIC8vICAgcmV0dXJuIHRoaXMuZ2V0TGlrZWxpZXN0TGFiZWwoKTtcbiAgLy8gfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnRseSBlc3RpbWF0ZWQgbGlrZWxpZXN0IGxhYmVsLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0TGlrZWxpZXN0TGFiZWwoKSB7XG4gICAgaWYgKHRoaXMuX21vZGVsUmVzdWx0cykge1xuICAgICAgaWYgKHRoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3QgPiAtMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWwubW9kZWxzW3RoaXMuX21vZGVsUmVzdWx0cy5saWtlbGllc3RdLmxhYmVsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ3Vua25vd24nOyAgICBcbiAgfVxuXG4gIC8qKipcbiAgICogTnVtYmVyIG9mIGNsYXNzZXMgY29udGFpbmVkIGluIHRoZSBtb2RlbC5cbiAgICogQHJlYWRvbmx5XG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICAvLyBnZXQgbmJDbGFzc2VzKCkge1xuICAvLyAgIHJldHVybiB0aGlzLmdldE51bWJlck9mQ2xhc3NlcygpO1xuICAvLyB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdG90YWwgbnVtYmVyIG9mIGNsYXNzZXMgdGhlIG1vZGVsIHdhcyB0cmFpbmVkIHdpdGguXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBnZXROdW1iZXJPZkNsYXNzZXMoKSB7XG4gICAgaWYgKHRoaXMuX21vZGVsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbW9kZWwubW9kZWxzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKioqXG4gICAqIFNpemUgb2YgdGhlIHJlZ3Jlc3Npb24gdmVjdG9yIGlmIG1vZGVsIGlzIGJpbW9kYWwuXG4gICAqIEByZWFkb25seVxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgLy8gZ2V0IHJlZ3Jlc3Npb25TaXplKCkge1xuICAvLyAgIHJldHVybiB0aGlzLmdldFJlZ3Jlc3Npb25WZWN0b3JTaXplKCk7XG4gIC8vIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvdXRwdXQgZGltZW5zaW9uIG9mIHRoZSBtb2RlbCAoc2l6ZSBvZiBhIHJlZ3Jlc3Npb24gdmVjdG9yKS5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIGdldFJlZ3Jlc3Npb25WZWN0b3JTaXplKCkge1xuICAgIGlmICh0aGlzLl9tb2RlbCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fbW9kZWwuc2hhcmVkX3BhcmFtZXRlcnM7XG4gICAgICByZXR1cm4gcGFyYW1zWydiaW1vZGFsJ11cbiAgICAgICAgICAgPyBwYXJhbXNbJ2RpbWVuc2lvbiddIC0gcGFyYW1zWydkaW1lbnNpb25faW5wdXQnXVxuICAgICAgICAgICA6IDA7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBIaG1tRGVjb2RlcjsiXX0=